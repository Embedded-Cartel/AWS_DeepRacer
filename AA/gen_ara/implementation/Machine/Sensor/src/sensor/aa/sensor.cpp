///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : sensor.cpp
/// SOFTWARE COMPONENT NAME           : Sensor
/// GENERATED DATE                    : 2024-11-12 15:53:00
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "sensor/aa/sensor.h"
 
namespace sensor
{
namespace aa
{
 
Sensor::Sensor()
    : m_running(false), m_event_flag(false)
    , m_logger(ara::log::CreateLogger("SENS", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(2)
{
}
 
Sensor::~Sensor()
{
    m_lidar_driver->EndLidar();
    m_camera_driver->EndCamera();
}
 
bool Sensor::Initialize()
{
    printf("[Sensor::Initialize] Begin\n");
    m_logger.LogVerbose() << "Sensor::Initialize";
    
    bool init{true};
    
    m_RawData = std::make_shared<sensor::aa::port::RawData>();
    m_lidar_driver = std::make_shared<LidarDriver>("/dev/ttyUSB0", 115200);
    m_camera_driver = std::make_shared<CameraDriver>(0, 2);
    int result = m_lidar_driver->CreateLidar();
    if(!result) {
        printf("[Sensor] Fail to create lidar instance\n");
        init = false;
    }

     result = m_camera_driver->CreateCamera();
     if(!result) {
         fprintf(stderr, "[Sensor] Fail to create camera instance\n");
         init = false;
    }
    printf("[Sensor::Initialize] End\n");

    return init;
}
 
void Sensor::Start()
{
    m_logger.LogVerbose() << "Sensor::Start";
    
    m_RawData->Start();
    m_lidar_driver->StartLidar();
    // m_camera_driver->StartCamera();
    
    // run software component
    Run();
}
 
void Sensor::Terminate()
{
    m_logger.LogVerbose() << "Sensor::Terminate";
    m_running = false;
    m_event_flag = false;
    m_RawData->Terminate();
}
 
void Sensor::Run()
{
    m_logger.LogVerbose() << "Sensor::Run";
    
    m_running = true;
    m_workers.Async([this] { UpdateDatas(); });
    m_workers.Async([this] { ThrowEventCyclic(); });
    
    m_workers.Wait();
}

void Sensor::UpdateDatas() {
    while (m_running) {
        bool result_lidar = false;
        bool result_camera = true;

        deepracer::service::rawdata::skeleton::events::REvent::SampleType sensor_datas;
        result_lidar = UpdateLidarData(&sensor_datas);
        result_camera = UpdateCameraData(&sensor_datas);

        if (result_lidar & result_camera) {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_RawData->WriteDataREvent(sensor_datas);
            m_event_flag = true;
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void Sensor::ThrowEventCyclic() {
    while (m_running) {
        //std::lock_guard<std::mutex> lock(m_mutex);
        if (m_event_flag == true) {
        std::lock_guard<std::mutex> lock(m_mutex);
            m_RawData->SendEventREventTriggered();
            m_event_flag = false;
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
}


bool Sensor::UpdateLidarData(deepracer::service::rawdata::skeleton::events::REvent::SampleType* sensor_datas)
{
    return m_lidar_driver->GetLidarData(sensor_datas);;
}

bool Sensor::UpdateCameraData(deepracer::service::rawdata::skeleton::events::REvent::SampleType* sensor_datas)
{
    return m_camera_driver->GetCameraData(sensor_datas);;
} 

} /// namespace aa
} /// namespace sensor
