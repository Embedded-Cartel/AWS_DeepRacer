///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : sensor.cpp
/// SOFTWARE COMPONENT NAME           : Sensor
/// GENERATED DATE                    : 2024-11-12 15:53:00
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "sensor/aa/sensor.h"
 
namespace sensor
{
namespace aa
{
 
Sensor::Sensor()
    : m_running(false), m_event_flag(false)
    , m_logger(ara::log::CreateLogger("SENS", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(2)
{
}
 
Sensor::~Sensor()
{
    m_lidar_driver->EndLidar();
    m_camera_driver->EndCamera();
}
 
bool Sensor::Initialize()
{
    printf("[Sensor::Initialize] Begin\n");
    m_logger.LogVerbose() << "Sensor::Initialize";
    
    bool init{true};
    
    m_RawData = std::make_shared<sensor::aa::port::RawData>();
    m_lidar_driver = std::make_shared<LidarDriver>("/dev/ttyUSB0", 115200);
//    m_camera_driver = std::make_shared<CameraDriver>(0, 2);
    int result = m_lidar_driver->CreateLidar();
    if(!result) {
        printf("[Sensor] Fail to create lidar instance\n");
        init = false;
    }

//    result = m_camera_driver->CreateCamera();
//    if(!result) {
//        fprintf(stderr, "[Sensor] Fail to create camera instance\n");
//        init = false;
//    }
    printf("[Sensor::Initialize] End\n");

    return init;
}
 
void Sensor::Start()
{
    m_logger.LogVerbose() << "Sensor::Start";
    
    m_RawData->Start();
    m_lidar_driver->StartLidar();
//    m_camera_driver->StartCamera();
    
    // run software component
    Run();
}
 
void Sensor::Terminate()
{
    m_logger.LogVerbose() << "Sensor::Terminate";
    m_running = false;
    m_event_flag = false;
    m_RawData->Terminate();
}
 
void Sensor::Run()
{
    m_logger.LogVerbose() << "Sensor::Run";
    
    m_running = true;
    m_workers.Async([this] { UpdateDatas(); });
    m_workers.Async([this] { ThrowEventCyclic(); });
    // m_workers.Async([this] { m_RawData->SendEventREventCyclic(); });
    // m_workers.Async([this] { m_RawData->NotifyFieldRFieldCyclic(); });
    
    m_workers.Wait();
}

void Sensor::UpdateDatas() {
    while (m_running) {
        #if DEBUG_SH
	    printf("ksh_@@@ Start UpdateDatas\n");
        #endif
        bool result_lidar = false;
        bool result_camera = true;
        result_lidar = UpdateLidarData();
//        result_camera = UpdateCameraData();

        if (result_lidar & result_camera) {
            std::lock_guard<std::mutex> lock(m_mutex); // m_event_flag 때문
            m_event_flag = true;
        }

        std::this_thread::sleep_for(std::chrono::seconds(1));
        #if DEBUG_SH
	    printf("ksh_@@@ End UpdateDatas Loop\n");
        #endif
    }
}

void Sensor::ThrowEventCyclic() {
    while (m_running) {
        #if DEBUG_SH
	    printf("ksh_@@@ Start ThrowEventCyclic\n");
        #endif
        //std::lock_guard<std::mutex> lock(m_mutex);
        if (m_event_flag == true) {
        std::lock_guard<std::mutex> lock(m_mutex);
            // m_lidar_data->SendEventREventTriggered();
            // m_camera_data->SendEventREventTriggered();
            m_RawData->SendEventREventTriggered();
            m_event_flag = false;
        }

        std::this_thread::sleep_for(std::chrono::seconds(1)); // 1초보다 짧으면 좋을듯
        #if DEBUG_SH
	    printf("ksh_@@@ End ThrowEventCyclic Loop\n");
        #endif
    }
}


bool Sensor::UpdateLidarData()
{
    bool result = false;

    deepracer::service::rawdata::skeleton::events::REvent::SampleType lidarDatas;
    result = m_lidar_driver->GetLidarData(&lidarDatas);

    if (result) {
        m_RawData->WriteDataREvent(lidarDatas);
    }

    return result;
}

bool Sensor::UpdateCameraData()
{
    bool result = false;
    deepracer::service::rawdata::skeleton::events::REvent::SampleType cameraDatas;
    result = m_camera_driver->GetCameraData(&cameraDatas);
    if (result) {
        // Write Camera data to Calc
    }

    return result;
} 

} /// namespace aa
} /// namespace sensor
